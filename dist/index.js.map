{"version":3,"sources":["../src/index.ts","../src/si/index.ts"],"sourcesContent":["export { default as si } from './si'\r\n","export default (() => {\n  const errors = new Map([\n    [1, 'This object has been frozen and should not be mutated'],\n    [2, 'baseState and producer are incompatibles'],\n    [3, `Cannot merge these types, because they are different types`],\n  ])\n\n  const die = (errorNumber: number) => () =>\n    console.log(errors.get(errorNumber))\n\n  const immuterSet = (setToImmuter: any): Readonly<Set<unknown>> => {\n    setToImmuter.add = die(1)\n    setToImmuter.delete = die(1)\n    setToImmuter.clear = die(1)\n    return freeze(setToImmuter)\n  }\n\n  const immuterMap = (mapToImmuter: any): Readonly<Map<unknown, unknown>> => {\n    mapToImmuter.set = die(1)\n    mapToImmuter.delete = die(1)\n    mapToImmuter.clear = die(1)\n    return freeze(mapToImmuter)\n  }\n\n  const typeCheck = (elementToCheck: unknown) => {\n    const stringType = Reflect.apply(\n      Object.prototype.toString,\n      elementToCheck,\n      [],\n    )\n    return stringType\n      .substring(stringType.indexOf(' ') + 1, stringType.indexOf(']'))\n      .toLowerCase()\n  }\n\n  const isFunction = (state: unknown): state is (...props: unknown[]) => any =>\n    typeCheck(state) === 'function'\n\n  const isUndefined = (state: unknown): state is undefined =>\n    typeCheck(state) === 'undefined'\n\n  const freeze = <T>(object: T) => Object.freeze(object)\n\n  const freezeDeep = <T extends CloneType>(elementToFreeze: T): Readonly<T> => {\n    switch (typeCheck(elementToFreeze)) {\n      case 'object':\n        return freeze(createClone(elementToFreeze, freezeDeep))\n      case 'date':\n        return freeze(cloneDate(elementToFreeze as any)) as Readonly<T>\n      case 'array':\n        return freeze((elementToFreeze as any).map(freezeDeep))\n      case 'set':\n        return immuterSet(elementToFreeze as any) as Readonly<T>\n      case 'map': {\n        const freezedMap = new Map()\n        ;(elementToFreeze as any[]).forEach((value: unknown, key: unknown) => {\n          freezedMap.set(key, freezeDeep(value as any))\n        })\n        return immuterMap(freezedMap) as Readonly<T>\n      }\n      default:\n        return elementToFreeze\n    }\n  }\n\n  type CloneType =\n    | object\n    | Map<unknown, unknown>\n    | Set<unknown>\n    | unknown[]\n    | Date\n  type BaseStateType<T> = DraftState<T>\n  type DraftState<T> = T\n  type DraftResult<T> = DraftState<T> | void\n  type ProducerType<T> = (draftState: DraftState<T>) => DraftResult<T>\n  type ReturnProduce<\n    T,\n    K extends ProducerType<T> | undefined,\n  > = K extends ProducerType<T> ? T : Readonly<T>\n\n  type ProducerConfig = {\n    freeze: boolean\n  }\n\n  function produce<T extends CloneType>(\n    baseState: BaseStateType<T>,\n  ): Readonly<T>\n  function produce<T extends CloneType>(\n    baseState: BaseStateType<T>,\n    producer: ProducerType<T>,\n    config: ProducerConfig,\n  ): ReturnProduce<Readonly<T>, typeof producer>\n  function produce<T extends CloneType>(\n    baseState: BaseStateType<T>,\n    producer: ProducerType<T>,\n  ): ReturnProduce<Readonly<T>, typeof producer>\n  function produce<T extends CloneType>(\n    baseState: BaseStateType<T>,\n    producer?: ProducerType<T>,\n    config: ProducerConfig = { freeze: true },\n  ): ReturnProduce<Readonly<T>, typeof producer> {\n    const clonedBaseState = cloneDeep(baseState)\n\n    if (isUndefined(producer)) {\n      return freezeDeep(clonedBaseState)\n    }\n\n    if (isFunction(producer)) {\n      const result = producer(clonedBaseState)\n\n      if (isValidToFreeze(result)) return freezeDeep(clonedBaseState)\n      if (isUndefined(result)) return clonedBaseState\n      if (config.freeze) return freezeDeep(result)\n      return result\n    }\n\n    throw new Error(errors.get(3))\n\n    function isValidToFreeze(producedResult: unknown) {\n      return isUndefined(producedResult) && config.freeze\n    }\n  }\n\n  const createClone = (\n    anObject: object,\n    strategy: (...args: any) => unknown,\n  ) => {\n    const descriptors = Object.getOwnPropertyDescriptors(anObject)\n    const cloneObj = Object.create(Object.getPrototypeOf(anObject), descriptors)\n\n    for (const descriptor of Reflect.ownKeys(descriptors)) {\n      if (!isEligible(descriptor)) continue\n      cloneObj[descriptor] = strategy(Reflect.get(anObject, descriptor))\n    }\n\n    return cloneObj\n\n    function isEligible(descriptor: string | symbol) {\n      return (\n        descriptors[String(descriptor)] &&\n        Reflect.has(descriptors[String(descriptor)], 'value')\n      )\n    }\n  }\n\n  const cloneArray = <T extends any[]>(elementToClone: T) =>\n    elementToClone.map(cloneDeep)\n\n  const cloneObject = <T extends { [key: string | symbol]: any }>(\n    elementToClone: T,\n  ): T => {\n    return createClone(elementToClone, cloneDeep)\n  }\n\n  const cloneDate = (aDate: Date): Date => new Date(aDate)\n\n  const cloneMap = <K, V extends CloneType>(elementToClone: Map<K, V>) => {\n    const clonedMap = new Map()\n    elementToClone.forEach((value, key) => {\n      clonedMap.set(key, cloneDeep(value))\n    })\n    return clonedMap\n  }\n\n  const cloneSet = <T extends CloneType>(\n    elementToClone: Set<T>,\n  ): Set<unknown> => {\n    const clonedSet = new Set()\n    elementToClone.forEach((value) => clonedSet.add(cloneDeep(value)))\n    return clonedSet\n  }\n\n  function assertTypeOf<T>(\n    anElement: unknown,\n    aType: string,\n  ): asserts anElement is T {\n    if (typeCheck(anElement) !== aType)\n      throw new Error(`element is not type of [${aType}]`)\n  }\n\n  const cloneDeep = <T extends CloneType>(anElement: T): T => {\n    switch (typeCheck(anElement)) {\n      case 'object':\n        return cloneObject(anElement)\n      case 'array':\n        assertTypeOf<Array<unknown>>(anElement, 'array')\n        return cloneArray(anElement) as T\n      case 'map':\n        assertTypeOf<Map<unknown, CloneType>>(anElement, 'map')\n        return cloneMap(anElement) as T\n      case 'set':\n        assertTypeOf<Set<CloneType>>(anElement, 'set')\n        return cloneSet(anElement) as T\n      case 'date':\n        assertTypeOf<Date>(anElement, 'date')\n        return cloneDate(anElement) as T\n      default:\n        return anElement\n    }\n  }\n\n  return {\n    produce,\n    cloneDeep,\n    freezeDeep,\n  }\n})()\n"],"mappings":"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","names":["src_exports","__export","si_default","__toCommonJS","si_default","errors","die","errorNumber","immuterSet","setToImmuter","freeze","immuterMap","mapToImmuter","typeCheck","elementToCheck","stringType","isFunction","state","isUndefined","object","freezeDeep","elementToFreeze","createClone","cloneDate","freezedMap","value","key","produce","baseState","producer","config","clonedBaseState","cloneDeep","result","isValidToFreeze","producedResult","anObject","strategy","descriptors","cloneObj","descriptor","isEligible","cloneArray","elementToClone","cloneObject","aDate","cloneMap","clonedMap","cloneSet","clonedSet","assertTypeOf","anElement","aType"]}