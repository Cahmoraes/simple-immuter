{"version":3,"sources":["../src/index.ts","../src/si/index.ts"],"sourcesContent":["export { default as si } from './si'\n","export default (() => {\n  const errors = new Map([\n    [1, 'This object has been frozen and should not be mutated'],\n    [2, 'baseState and producer are incompatibles'],\n    [3, `Cannot merge these types, because they are different types`],\n  ])\n\n  const die = (errorNumber: number) => () =>\n    console.log(errors.get(errorNumber))\n\n  const pipe =\n    (...fns: any[]) =>\n    (value: any) =>\n      fns.reduce((acc, fn) => fn(acc), value)\n\n  const flat = (element: any, depth = Infinity) => {\n    if (typeCheck(element) !== 'array') return element\n    return depth > 0\n      ? element.reduce(\n          (flatArray: any[], array: any[]) =>\n            flatArray.concat(flat(array, --depth)),\n          [],\n        )\n      : element\n  }\n\n  const createObjectFromEntries = (entries: any[]) =>\n    Object.fromEntries(entries)\n\n  const getKeysAndSymbolsFromObject = (object: object) =>\n    Reflect.ownKeys(object)\n\n  const immuterSet = (setToImmuter: any): Set<any> => {\n    setToImmuter.add = die(1)\n    setToImmuter.delete = die(1)\n    setToImmuter.clear = die(1)\n    return setToImmuter\n  }\n\n  const immuterMap = (mapToImmuter: any) => {\n    mapToImmuter.set = die(1)\n    mapToImmuter.delete = die(1)\n    mapToImmuter.clear = die(1)\n    return mapToImmuter\n  }\n\n  const setPrototypeOf = (prototype: object) => (object: object) =>\n    Object.setPrototypeOf(object, prototype)\n\n  const getPrototypeOf = <T>(object: T) => Object.getPrototypeOf(object)\n\n  const typeCheck = (elementToCheck: unknown) => {\n    const stringType = Reflect.apply(\n      Object.prototype.toString,\n      elementToCheck,\n      [],\n    )\n    return stringType\n      .substring(stringType.indexOf(' ') + 1, stringType.indexOf(']'))\n      .toLowerCase()\n  }\n\n  const isArray = <T>(state: unknown): state is Array<T> =>\n    typeCheck(state) === 'array'\n\n  const isObject = <T>(state: unknown): state is T =>\n    typeCheck(state) === 'object'\n\n  const isFunction = (state: unknown): state is (...props: unknown[]) => any =>\n    typeCheck(state) === 'function'\n\n  const isPromise = <T>(state: unknown): state is Promise<T> =>\n    typeCheck(state) === 'promise'\n\n  const isUndefined = (state: unknown): state is undefined =>\n    typeCheck(state) === 'undefined'\n\n  const areDifferent = (...types: unknown[]) => {\n    for (let j = 0, i = j + 1; i < types.length; i = j + 1, j++) {\n      if (typeCheck(types[j]) !== typeCheck(types[i])) {\n        return true\n      }\n    }\n    return false\n  }\n\n  const arrayEveryArray = <T>(states: T[]): states is T[] =>\n    states.every(isArray)\n\n  const arrayEveryObject = <T>(states: T[]): states is T[] =>\n    states.every(isObject)\n\n  const areAllSameType =\n    <T, K>(type: T) =>\n    (...objs: K[]): boolean =>\n      objs.every((obj) => typeCheck(obj) === type)\n\n  const areAllObjects = areAllSameType('object')\n\n  const areAllArrays = areAllSameType('array')\n\n  const freeze = <T>(object: T) => Object.freeze(object)\n\n  const mergeAllObjectsOrArrays = (\n    clonedBaseState: any,\n    producer: any,\n    states: any[],\n  ) => {\n    if (areAllObjects(clonedBaseState, producer) && arrayEveryObject(states)) {\n      try {\n        return freezeDeep(Object.assign(clonedBaseState, producer, ...states))\n      } catch {\n        throw new Error(errors.get(2))\n      }\n    }\n\n    if (areAllArrays(clonedBaseState, producer) && arrayEveryArray(states)) {\n      try {\n        return freezeDeep([...clonedBaseState, ...producer, ...flat(states, 1)])\n      } catch {\n        throw new Error(errors.get(2))\n      }\n    }\n\n    throw new Error(errors.get(3))\n  }\n\n  const freezeDeep = (elementToFreeze: any): any => {\n    switch (typeCheck(elementToFreeze)) {\n      case 'object':\n        return pipe(\n          createObjectFromEntries,\n          setPrototypeOf(getPrototypeOf(elementToFreeze)),\n          freeze,\n        )(\n          getKeysAndSymbolsFromObject(elementToFreeze).map((key) => [\n            key,\n            freezeDeep(elementToFreeze[key]),\n          ]),\n        )\n      case 'array':\n        return freeze(elementToFreeze.map(freezeDeep))\n      case 'set':\n        return immuterSet(elementToFreeze)\n      case 'map': {\n        const freezedMap = new Map()\n        elementToFreeze.forEach((value: unknown, key: unknown) => {\n          freezedMap.set(key, freezeDeep(value))\n        })\n        return immuterMap(freezedMap)\n      }\n      default:\n        return elementToFreeze\n    }\n  }\n\n  const producePromise = async (baseState: Promise<any>, producer: any) => {\n    try {\n      const resolvedState = await baseState\n      if (isUndefined(producer)) {\n        return freezeDeep(resolvedState)\n      }\n\n      if (isFunction(producer)) {\n        producer(resolvedState)\n        return freezeDeep(resolvedState)\n      }\n    } catch (error: any) {\n      return new Error(error)\n    }\n  }\n\n  type BaseStateType<T> = T | Promise<T>\n\n  type DraftState<T> = T & { [key: string]: any }\n\n  type ProducerType<T> = ((draftState: DraftState<T>) => void) | object\n\n  type ProduceProps = <T>(\n    baseState: BaseStateType<T>,\n    producer?: ProducerType<T>,\n    ...states: any[]\n  ) => any\n\n  const produce: ProduceProps = <T>(\n    baseState: BaseStateType<T>,\n    producer?: ProducerType<T>,\n    ...states: any[]\n  ) => {\n    if (isPromise(baseState)) {\n      return producePromise(baseState, producer)\n    }\n\n    const clonedBaseState = cloneDeep(baseState)\n    if (isUndefined(producer)) {\n      return freezeDeep(clonedBaseState)\n    }\n\n    if (isFunction(producer)) {\n      producer(clonedBaseState)\n      return freezeDeep(clonedBaseState)\n    }\n\n    if (states.length > 0) {\n      return mergeAllObjectsOrArrays(clonedBaseState, producer, states)\n    }\n\n    if (areAllObjects(clonedBaseState, producer)) {\n      return freezeDeep(Object.assign(clonedBaseState, producer))\n    }\n\n    if (areAllArrays(clonedBaseState, producer)) {\n      if (Array.isArray(producer)) {\n        return freezeDeep([...clonedBaseState, ...producer])\n      }\n    }\n\n    if (areDifferent(clonedBaseState, producer)) {\n      throw new Error(errors.get(2))\n    } else {\n      throw new Error(errors.get(3))\n    }\n  }\n\n  const cloneArray = (elementToClone: unknown[]): unknown[] =>\n    elementToClone.map(cloneDeep)\n\n  const cloneObject = <T extends { [hey: string | symbol]: any }>(\n    elementToClone: T,\n  ): T => {\n    const prototype = Object.getPrototypeOf(elementToClone)\n    return pipe(\n      createObjectFromEntries,\n      setPrototypeOf(prototype),\n    )(\n      getKeysAndSymbolsFromObject(elementToClone).map((key) => [\n        key,\n        cloneDeep(elementToClone[key]),\n      ]),\n    )\n  }\n\n  const cloneMap = <K, V>(elementToClone: Map<K, V>) => {\n    const clonedMap = new Map()\n    elementToClone.forEach((value, key) => {\n      clonedMap.set(key, cloneDeep(value))\n    })\n    return clonedMap\n  }\n\n  const cloneSet = <T>(elementToClone: Set<T>): Set<unknown> => {\n    const clonedSet = new Set()\n    elementToClone.forEach((value) => clonedSet.add(cloneDeep(value)))\n    return clonedSet\n  }\n\n  const cloneDeep = (element: any): any => {\n    switch (typeCheck(element)) {\n      case 'object':\n        return cloneObject(element)\n      case 'array':\n        return cloneArray(element)\n      case 'map':\n        return cloneMap(element)\n      case 'set':\n        return cloneSet(element)\n      default:\n        return element\n    }\n  }\n\n  return {\n    produce,\n  }\n})()\n"],"mappings":"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","names":["src_exports","__export","si_default","__toCommonJS","si_default","errors","die","errorNumber","pipe","fns","value","acc","fn","flat","element","depth","typeCheck","flatArray","array","createObjectFromEntries","entries","getKeysAndSymbolsFromObject","object","immuterSet","setToImmuter","immuterMap","mapToImmuter","setPrototypeOf","prototype","getPrototypeOf","elementToCheck","stringType","isArray","state","isObject","isFunction","isPromise","isUndefined","areDifferent","types","j","i","arrayEveryArray","states","arrayEveryObject","areAllSameType","type","objs","obj","areAllObjects","areAllArrays","freeze","mergeAllObjectsOrArrays","clonedBaseState","producer","freezeDeep","elementToFreeze","key","freezedMap","producePromise","baseState","resolvedState","error","produce","cloneDeep","cloneArray","elementToClone","cloneObject","cloneMap","clonedMap","cloneSet","clonedSet"]}