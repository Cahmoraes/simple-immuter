{"version":3,"sources":["../src/index.ts","../src/si/index.ts"],"sourcesContent":["export { default as si } from './si'\n","export default (() => {\n  const errors = new Map([\n    [1, 'This object has been frozen and should not be mutated'],\n    [2, 'baseState and producer are incompatibles'],\n    [3, `Cannot merge these types, because they are different types`],\n  ])\n\n  const die = (errorNumber: number) => () =>\n    console.log(errors.get(errorNumber))\n\n  const pipe =\n    (...fns: any[]) =>\n    (value: any) =>\n      fns.reduce((acc, fn) => fn(acc), value)\n\n  const createObjectFromEntries = (entries: any[]) =>\n    Object.fromEntries(entries)\n\n  const getKeysAndSymbolsFromObject = (object: object) =>\n    Reflect.ownKeys(object)\n\n  const immuterSet = (setToImmuter: any): Set<any> => {\n    setToImmuter.add = die(1)\n    setToImmuter.delete = die(1)\n    setToImmuter.clear = die(1)\n    return setToImmuter\n  }\n\n  const immuterMap = (mapToImmuter: any) => {\n    mapToImmuter.set = die(1)\n    mapToImmuter.delete = die(1)\n    mapToImmuter.clear = die(1)\n    return mapToImmuter\n  }\n\n  const setPrototypeOf = (prototype: object) => (object: object) =>\n    Object.setPrototypeOf(object, prototype)\n\n  const getPrototypeOf = <T>(object: T) => Object.getPrototypeOf(object)\n\n  const typeCheck = (elementToCheck: unknown) => {\n    const stringType = Reflect.apply(\n      Object.prototype.toString,\n      elementToCheck,\n      [],\n    )\n    return stringType\n      .substring(stringType.indexOf(' ') + 1, stringType.indexOf(']'))\n      .toLowerCase()\n  }\n\n  const isFunction = (state: unknown): state is (...props: unknown[]) => any =>\n    typeCheck(state) === 'function'\n\n  const isUndefined = (state: unknown): state is undefined =>\n    typeCheck(state) === 'undefined'\n\n  const freeze = <T>(object: T) => Object.freeze(object)\n\n  const deepFreeze = <T extends CloneType>(elementToFreeze: T): T => {\n    switch (typeCheck(elementToFreeze)) {\n      case 'object':\n        return pipe(\n          createObjectFromEntries,\n          setPrototypeOf(getPrototypeOf(elementToFreeze)),\n          freeze,\n        )(\n          getKeysAndSymbolsFromObject(elementToFreeze).map((key) => [\n            key,\n            deepFreeze((elementToFreeze as any)[key]),\n          ]),\n        )\n      case 'array':\n        return freeze((elementToFreeze as any).map(deepFreeze))\n      case 'set':\n        return immuterSet(elementToFreeze as any) as T\n      case 'map': {\n        const freezedMap = new Map()\n        ;(elementToFreeze as any[]).forEach((value: unknown, key: unknown) => {\n          freezedMap.set(key, deepFreeze(value as any))\n        })\n        return immuterMap(freezedMap)\n      }\n      default:\n        return elementToFreeze\n    }\n  }\n\n  type CloneType = object | Map<unknown, unknown> | Set<unknown> | unknown[]\n  type BaseStateType<T> = DraftState<T>\n  type DraftState<T> = T & { [key: string]: any }\n  type DraftResult<T> = DraftState<T> | void\n  type ProducerType<T> = (draftState: DraftState<T>) => DraftResult<T>\n  type ReturnProduce<\n    T,\n    K extends ProducerType<T> | undefined,\n  > = K extends ProducerType<T> ? T & { [key: string]: any } : T\n\n  function produce<T extends CloneType>(baseState: BaseStateType<T>): T\n  function produce<T extends CloneType>(\n    baseState: BaseStateType<T>,\n    producer: ProducerType<T>,\n  ): ReturnProduce<T, typeof producer>\n  function produce<T extends CloneType>(\n    baseState: BaseStateType<T>,\n    producer?: ProducerType<T>,\n  ): ReturnProduce<T, typeof producer> {\n    const clonedBaseState = deepClone(baseState)\n\n    if (isUndefined(producer)) {\n      return deepFreeze(clonedBaseState)\n    }\n\n    if (isFunction(producer)) {\n      producer(clonedBaseState)\n      return deepFreeze(clonedBaseState)\n    }\n\n    throw new Error(errors.get(3))\n  }\n\n  const cloneArray = <T extends any[]>(elementToClone: T) =>\n    elementToClone.map(deepClone)\n\n  const cloneObject = <T extends { [hey: string | symbol]: any }>(\n    elementToClone: T,\n  ): T => {\n    const prototype = Object.getPrototypeOf(elementToClone)\n    return pipe(\n      createObjectFromEntries,\n      setPrototypeOf(prototype),\n    )(\n      getKeysAndSymbolsFromObject(elementToClone).map((key) => [\n        key,\n        deepClone(elementToClone[key]),\n      ]),\n    )\n  }\n\n  const cloneMap = <K, V extends CloneType>(elementToClone: Map<K, V>) => {\n    const clonedMap = new Map()\n    elementToClone.forEach((value, key) => {\n      clonedMap.set(key, deepClone(value))\n    })\n    return clonedMap\n  }\n\n  const cloneSet = <T extends CloneType>(\n    elementToClone: Set<T>,\n  ): Set<unknown> => {\n    const clonedSet = new Set()\n    elementToClone.forEach((value) => clonedSet.add(deepClone(value)))\n    return clonedSet\n  }\n\n  const deepClone = <T extends CloneType>(element: T): T => {\n    switch (typeCheck(element)) {\n      case 'object':\n        return cloneObject(element)\n      case 'array':\n        return cloneArray(element as any[]) as T\n      case 'map':\n        return cloneMap(element as Map<any, any>) as T\n      case 'set':\n        return cloneSet(element as Set<any>) as T\n      default:\n        return element\n    }\n  }\n\n  return {\n    produce,\n    deepClone,\n    deepFreeze,\n  }\n})()\n"],"mappings":"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","names":["src_exports","__export","si_default","__toCommonJS","si_default","errors","die","errorNumber","pipe","fns","value","acc","fn","createObjectFromEntries","entries","getKeysAndSymbolsFromObject","object","immuterSet","setToImmuter","immuterMap","mapToImmuter","setPrototypeOf","prototype","getPrototypeOf","typeCheck","elementToCheck","stringType","isFunction","state","isUndefined","freeze","deepFreeze","elementToFreeze","key","freezedMap","produce","baseState","producer","clonedBaseState","deepClone","cloneArray","elementToClone","cloneObject","cloneMap","clonedMap","cloneSet","clonedSet","element"]}