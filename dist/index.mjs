var h=(()=>{let p=new Map([[1,"This object has been frozen and should not be mutated"],[2,"baseState and producer are incompatibles"],[3,"Cannot merge these types, because they are different types"]]),a=e=>()=>console.log(p.get(e)),i=e=>(e.add=a(1),e.delete=a(1),e.clear=a(1),d(e)),l=e=>(e.set=a(1),e.delete=a(1),e.clear=a(1),d(e)),u=e=>{let n=Reflect.apply(Object.prototype.toString,e,[]);return n.substring(n.indexOf(" ")+1,n.indexOf("]")).toLowerCase()},w=e=>u(e)==="function",S=e=>u(e)==="undefined",d=e=>Object.freeze(e),o=e=>{switch(u(e)){case"object":return d(T(e,o));case"date":return d(f(e));case"array":return d(e.map(o));case"set":return i(e);case"map":{let n=new Map;return e.forEach((t,r)=>{n.set(r,o(t))}),l(n)}default:return e}};function b(e,n){let t=s(e);if(S(n))return o(t);if(w(n)){let r=n(t);return o(r||t)}throw new Error(p.get(3))}let T=(e,n)=>{let t=Object.getOwnPropertyDescriptors(e),r=Object.create(Object.getPrototypeOf(e),t);for(let c of Reflect.ownKeys(t))!D(c)||(r[c]=n(Reflect.get(e,c)));return r;function D(c){return t[String(c)]&&Reflect.has(t[String(c)],"value")}},k=e=>e.map(s),R=e=>T(e,s),f=e=>new Date(e),g=e=>{let n=new Map;return e.forEach((t,r)=>{n.set(r,s(t))}),n},x=e=>{let n=new Set;return e.forEach(t=>n.add(s(t))),n};function y(e,n){if(u(e)!==n)throw new Error(`element is not type of [${n}]`)}let s=e=>{switch(u(e)){case"object":return R(e);case"array":return y(e,"array"),k(e);case"map":return y(e,"map"),g(e);case"set":return y(e,"set"),x(e);case"date":return y(e,"date"),f(e);default:return e}};return{produce:b,cloneDeep:s,freezeDeep:o}})();export{h as si};
//# sourceMappingURL=index.mjs.map