var A=(()=>{let y=new Map([[1,"This object has been frozen and should not be mutated"],[2,"baseState and producer are incompatibles"],[3,"Cannot merge these types, because they are different types"]]),a=t=>()=>console.log(y.get(t)),i=(...t)=>e=>t.reduce((n,o)=>o(n),e),u=(t,e=1/0)=>e>0?t.reduce((n,o)=>n.concat(u(o,--e)),[]):t,p=t=>Object.fromEntries(t),d=t=>Reflect.ownKeys(t),P=t=>(t.add=a(1),t.delete=a(1),t.clear=a(1),t),g=t=>(t.set=a(1),t.delete=a(1),t.clear=a(1),t),f=t=>e=>Object.setPrototypeOf(e,t),S=t=>Object.getPrototypeOf(t),s=t=>{let e=Reflect.apply(Object.prototype.toString,t,[]);return e.substring(e.indexOf(" ")+1,e.indexOf("]")).toLowerCase()},T=t=>s(t)==="array",b=t=>s(t)==="object",w=t=>s(t)==="function",h=t=>s(t)==="promise",j=t=>s(t)==="undefined",k=t=>t.every(T),l=t=>t.every(b),O=t=>Object.freeze(t),r=t=>{switch(s(t)){case"object":return i(p,f(S(t)),O)(d(t).map(e=>[e,r(t[e])]));case"array":return O(t.map(r));case"set":return P(t);case"map":{let e=new Map;return t.forEach((n,o)=>{e.set(o,r(n))}),g(e)}default:return t}},E=async(t,e)=>{try{let n=await t;if(j(e))return r(n);if(w(e))return e(n),r(n)}catch(n){return new Error(n)}},M=(t,e)=>{if(h(t))return E(t,e);let n=c(t);if(j(e))return r(n);if(w(e))return e(n),r(n);throw new Error(y.get(3))},K=t=>t.map(c),v=t=>{let e=Object.getPrototypeOf(t);return i(p,f(e))(d(t).map(n=>[n,c(t[n])]))},x=t=>{let e=new Map;return t.forEach((n,o)=>{e.set(o,c(n))}),e},B=t=>{let e=new Set;return t.forEach(n=>e.add(c(n))),e},c=t=>{switch(s(t)){case"object":return v(t);case"array":return K(t);case"map":return x(t);case"set":return B(t);default:return t}};return{produce:M,merge:(t,...e)=>{let n=c(t);if(T(n)&&k(e))return r([...n,...u(e,1)]);if(b(t)&&l(e))return r(Object.assign(n,...e));throw new Error(y.get(3))}}})();export{A as si};
//# sourceMappingURL=index.mjs.map