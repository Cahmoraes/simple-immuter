var D=(()=>{let p=new Map([[1,"This object has been frozen and should not be mutated"],[2,"baseState and producer are incompatibles"],[3,"Cannot merge these types, because they are different types"]]),r=e=>()=>console.log(p.get(e)),f=e=>(e.add=r(1),e.delete=r(1),e.clear=r(1),d(e)),l=e=>(e.set=r(1),e.delete=r(1),e.clear=r(1),d(e)),u=e=>{let n=Reflect.apply(Object.prototype.toString,e,[]);return n.substring(n.indexOf(" ")+1,n.indexOf("]")).toLowerCase()},w=e=>u(e)==="function",S=e=>u(e)==="undefined",d=e=>Object.freeze(e),o=e=>{switch(u(e)){case"object":return d(T(e,o));case"date":return d(i(e));case"array":return d(e.map(o));case"set":return f(e);case"map":{let n=new Map;return e.forEach((t,s)=>{n.set(s,o(t))}),l(n)}default:return e}};function b(e,n){let t=a(e);if(S(n))return o(t);if(w(n))return n(t),o(t);throw new Error(p.get(3))}let T=(e,n)=>{let t=Object.getOwnPropertyDescriptors(e),s=Object.create(Object.getPrototypeOf(e),t);for(let c of Reflect.ownKeys(t))!x(c)||(s[c]=n(Reflect.get(e,c)));return s;function x(c){return t[String(c)]&&Reflect.has(t[String(c)],"value")}},k=e=>e.map(a),R=e=>T(e,a),i=e=>new Date(e),g=e=>{let n=new Map;return e.forEach((t,s)=>{n.set(s,a(t))}),n},C=e=>{let n=new Set;return e.forEach(t=>n.add(a(t))),n};function y(e,n){if(u(e)!==n)throw new Error(`element is not type of [${n}]`)}let a=e=>{switch(u(e)){case"object":return R(e);case"array":return y(e,"array"),k(e);case"map":return y(e,"map"),g(e);case"set":return y(e,"set"),C(e);case"date":return y(e,"date"),i(e);default:return e}};return{produce:b,cloneDeep:a,freezeDeep:o}})();export{D as si};
//# sourceMappingURL=index.mjs.map