var x=(()=>{let y=new Map([[1,"This object has been frozen and should not be mutated"],[2,"baseState and producer are incompatibles"],[3,"Cannot merge these types, because they are different types"]]),o=e=>()=>console.log(y.get(e)),T=e=>(e.add=o(1),e.delete=o(1),e.clear=o(1),d(e)),i=e=>(e.set=o(1),e.delete=o(1),e.clear=o(1),d(e)),u=e=>{let n=Reflect.apply(Object.prototype.toString,e,[]);return n.substring(n.indexOf(" ")+1,n.indexOf("]")).toLowerCase()},f=e=>u(e)==="function",l=e=>u(e)==="undefined",d=e=>Object.freeze(e),r=e=>{switch(u(e)){case"object":return d(p(e,r));case"array":return d(e.map(r));case"set":return T(e);case"map":{let n=new Map;return e.forEach((t,s)=>{n.set(s,r(t))}),i(n)}default:return e}};function w(e,n){let t=a(e);if(l(n))return r(t);if(f(n))return n(t),r(t);throw new Error(y.get(3))}let p=(e,n)=>{let t=Object.getOwnPropertyDescriptors(e),s=Object.create(Object.getPrototypeOf(e),t);for(let c of Reflect.ownKeys(t))!g(c)||(s[c]=n(Reflect.get(e,c)));return s;function g(c){return t[String(c)]&&Reflect.has(t[String(c)],"value")}},S=e=>e.map(a),b=e=>p(e,a),k=e=>{let n=new Map;return e.forEach((t,s)=>{n.set(s,a(t))}),n},R=e=>{let n=new Set;return e.forEach(t=>n.add(a(t))),n},a=e=>{switch(u(e)){case"object":return b(e);case"array":return S(e);case"map":return k(e);case"set":return R(e);default:return e}};return{produce:w,cloneDeep:a,freezeDeep:r}})();export{x as si};
//# sourceMappingURL=index.mjs.map